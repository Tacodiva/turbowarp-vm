const Cast = require('../util/cast');
const StringUtil = require('../util/string-util');
const BlockType = require('../extension-support/block-type');
const Variable = require('../engine/variable');
const log = require('../util/log');
const {IntermediateStack, IntermediateInput, IntermediateScript, IntermediateRepresentation} = require('./intermediate');
const compatBlocks = require('./compat-blocks');
const {StackOpcode, InputOpcode, InputType} = require('./enums.js')

/**
 * @fileoverview Generate intermediate representations from Scratch blocks.
 */

const SCALAR_TYPE = '';
const LIST_TYPE = 'list';

/**
 * Create a variable codegen object.
 * @param {'target'|'stage'} scope The scope of this variable -- which object owns it.
 * @param {import('../engine/variable.js')} varObj The Scratch Variable
 * @returns {*} A variable codegen object.
 */
const createVariableData = (scope, varObj) => ({
    scope,
    id: varObj.id,
    name: varObj.name,
    isCloud: varObj.isCloud
});

/**
 * @param {string} code
 * @param {boolean} warp
 * @returns {string}
 */
const generateProcedureVariant = (code, warp) => {
    if (warp) {
        return `W${code}`;
    }
    return `Z${code}`;
};

/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {string} original procedure code
 */
const parseProcedureCode = variant => variant.substring(1);

/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {boolean} true if warp enabled
 */
const parseIsWarp = variant => variant.charAt(0) === 'W';

class ScriptTreeGenerator {
    constructor (thread) {
        /** @private */
        this.thread = thread;
        /** @private */
        this.target = thread.target;
        /** @private */
        this.blocks = thread.blockContainer;
        /** @private */
        this.runtime = this.target.runtime;
        /** @private */
        this.stage = this.runtime.getTargetForStage();

        /**
         * This script's intermediate representation.
         */
        this.script = new IntermediateScript();
        this.script.warpTimer = this.target.runtime.compilerOptions.warpTimer;

        /**
         * Cache of variable ID to variable data object.
         * @type {Object.<string, object>}
         * @private
         */
        this.variableCache = {};

        this.usesTimer = false;

        this.namesOfCostumesAndSounds = new Set();
        for (const target of this.runtime.targets) {
            if (target.isOriginal) {
                const sprite = target.sprite;
                for (const costume of sprite.costumes) {
                    this.namesOfCostumesAndSounds.add(costume.name);
                }
                for (const sound of sprite.sounds) {
                    this.namesOfCostumesAndSounds.add(sound.name);
                }
            }
        }
    }

    setProcedureVariant (procedureVariant) {
        const procedureCode = parseProcedureCode(procedureVariant);

        this.script.procedureCode = procedureCode;
        this.script.isProcedure = true;
        this.script.yields = false;

        const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
        if (paramNamesIdsAndDefaults === null) {
            throw new Error(`IR: cannot find procedure: ${procedureVariant}`);
        }

        const [paramNames, _paramIds, _paramDefaults] = paramNamesIdsAndDefaults;
        this.script.arguments = paramNames;
    }

    enableWarp () {
        this.script.isWarp = true;
    }

    getBlockById (blockId) {
        // Flyout blocks are stored in a special container.
        return this.blocks.getBlock(blockId) || this.blocks.runtime.flyoutBlocks.getBlock(blockId);
    }

    getBlockInfo (fullOpcode) {
        const [category, opcode] = StringUtil.splitFirst(fullOpcode, '_');
        if (!category || !opcode) {
            return null;
        }
        const categoryInfo = this.runtime._blockInfo.find(ci => ci.id === category);
        if (!categoryInfo) {
            return null;
        }
        const blockInfo = categoryInfo.blocks.find(b => b.info.opcode === opcode);
        if (!blockInfo) {
            return null;
        }
        return blockInfo;
    }

    createConstantInput(constant, preserveStrings = false) {
        if (constant == null) throw new Error("IR: Constant cannot have a null value.");

        constant += '';
        const numConstant = +constant;

        if (!Number.isNaN(numConstant) && constant.trim() !== '') {
            if (!(preserveStrings && this.namesOfCostumesAndSounds.has(constant)) && numConstant.toString() === constant) {
                return new IntermediateInput(InputOpcode.CONSTANT, IntermediateInput.getNumberInputType(numConstant), { value: numConstant });
            }            
            return new IntermediateInput(InputOpcode.CONSTANT, InputType.STRING_NUM, { value: constant });
        }

        return new IntermediateInput(InputOpcode.CONSTANT, InputType.STRING_NAN, { value: constant });
    }

    /**
     * Descend into a child input of a block. (eg. the input STRING of "length of ( )")
     * @param {*} parentBlock The parent Scratch block that contains the input.
     * @param {string} inputName The name of the input to descend into.
     * @param {boolean} preserveStrings Should this input keep the names of costumes and sounds at strings.
     * @private
     * @returns {IntermediateInput} Compiled input node for this input.
     */
    descendInputOfBlock (parentBlock, inputName, preserveStrings = false) {
        const input = parentBlock.inputs[inputName];
        if (!input) {
            log.warn(`IR: ${parentBlock.opcode}: missing input ${inputName}`, parentBlock);
            return this.createConstantInput(0);
        }
        const inputId = input.block;
        const block = this.getBlockById(inputId);
        if (!block) {
            log.warn(`IR: ${parentBlock.opcode}: could not find input ${inputName} with ID ${inputId}`);
            return this.createConstantInput(0);
        }

        return this.descendInput(block, preserveStrings);
    }

    /**
     * Descend into an input. (eg. "length of ( )")
     * @param {*} block The parent Scratch block input.
     * @param {boolean} preserveStrings Should this input keep the names of costumes and sounds at strings.
     * @private
     * @returns {IntermediateInput} Compiled input node for this input.
     */
    descendInput (block, preserveStrings = false) {
        switch (block.opcode) {
        case 'colour_picker':
            return this.createConstantInput(block.fields.COLOUR.value);
        case 'math_angle':
        case 'math_integer':
        case 'math_number':
        case 'math_positive_number':
        case 'math_whole_number':
            return this.createConstantInput(block.fields.NUM.value, preserveStrings);
        case 'text':
            return this.createConstantInput(block.fields.TEXT.value, preserveStrings);
        case 'argument_reporter_string_number': {
            const name = block.fields.VALUE.value;
            // lastIndexOf because multiple parameters with the same name will use the value of the last definition
            const index = this.script.arguments.lastIndexOf(name);
            if (index === -1) {
                // Legacy support
                if (name.toLowerCase() === 'last key pressed') {
                    return new IntermediateInput(InputOpcode.TW_KEY_LAST_PRESSED, InputType.STRING);
                }
            }
            if (index === -1) {
                return this.createConstantInput(0);
            }
            return new IntermediateInput(InputOpcode.PROCEDURE_ARG_STRING_NUMBER, InputType.ANY, {index});
        }
        case 'argument_reporter_boolean': {
            // see argument_reporter_string_number above
            const name = block.fields.VALUE.value;
            const index = this.script.arguments.lastIndexOf(name);
            if (index === -1) {
                if (name.toLowerCase() === 'is compiled?' || name.toLowerCase() === 'is turbowarp?') {
                    return this.createConstantInput(true);
                }
                return this.createConstantInput(0);
            }
            return new IntermediateInput(InputOpcode.PROCEDURE_ARG_BOOLEAN, InputType.BOOLEAN, {index});
        }

        case 'control_get_counter':
            return {
                kind: 'counter.get'
            };

        case 'data_variable':
            return new IntermediateInput(InputOpcode.VAR_GET, InputType.ANY, {
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            });
        case 'data_itemoflist':
            return new IntermediateInput(InputOpcode.LIST_GET, InputType.ANY, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX')
            });
        case 'data_lengthoflist':
            return new IntermediateInput(InputOpcode.LIST_LENGTH, InputType.NUMBER, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            });
        case 'data_listcontainsitem':
            return new IntermediateInput(InputOpcode.LIST_CONTAINS, InputType.BOOLEAN, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM')
            });
        case 'data_itemnumoflist':
            return new IntermediateInput(InputOpcode.LIST_INDEX_OF, InputType.NUMBER, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM')
            });
        case 'data_listcontents':
            return new IntermediateInput(InputOpcode.LIST_CONTENTS, InputType.STRING, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            });

        case 'event_broadcast_menu': {
            const broadcastOption = block.fields.BROADCAST_OPTION;
            const broadcastVariable = this.target.lookupBroadcastMsg(broadcastOption.id, broadcastOption.value);
            // TODO: empty string probably isn't the correct fallback
            const broadcastName = broadcastVariable ? broadcastVariable.name : '';
            return this.createConstantInput(broadcastName);
        }

        case 'looks_backdropnumbername':
            if (block.fields.NUMBER_NAME.value === 'number') {
                return new IntermediateInput(InputOpcode.LOOKS_BACKDROP_NUMBER, InputType.NUMBER);
            }
            return new IntermediateInput(InputOpcode.LOOKS_BACKDROP_NAME, InputType.STRING);
        case 'looks_costumenumbername':
            if (block.fields.NUMBER_NAME.value === 'number') {
                return new IntermediateInput(InputOpcode.LOOKS_COSTUME_NUMBER, InputType.NUMBER);
            }
            return new IntermediateInput(InputOpcode.LOOKS_COSTUME_NAME, InputType.STRING);
        case 'looks_size':
            return new IntermediateInput(InputOpcode.LOOKS_SIZE_GET, InputType.NUMBER);

        case 'motion_direction':
            return new IntermediateInput(InputOpcode.MOTION_DIRECTION_GET, InputType.NUMBER);
        case 'motion_xposition':
            return new IntermediateInput(InputOpcode.MOTION_X_GET, InputType.NUMBER);
        case 'motion_yposition':
            return new IntermediateInput(InputOpcode.MOTION_Y_GET, InputType.NUMBER);

        case 'operator_add':
            return new IntermediateInput(InputOpcode.OP_ADD, InputType.NUMBER_OR_NAN, {
                left: this.descendInputOfBlock(block, 'NUM1').toType(InputType.NUMBER),
                right: this.descendInputOfBlock(block, 'NUM2').toType(InputType.NUMBER)
            });
        case 'operator_and':
            return new IntermediateInput(InputOpcode.OP_AND, InputType.BOOLEAN, {
                left: this.descendInputOfBlock(block, 'OPERAND1').toType(InputType.BOOLEAN),
                right: this.descendInputOfBlock(block, 'OPERAND2').toType(InputType.BOOLEAN)
            });
        case 'operator_contains':
            return new IntermediateInput(InputOpcode.OP_CONTAINS, InputType.BOOLEAN, {
                string: this.descendInputOfBlock(block, 'STRING1').toType(InputType.STRING),
                contains: this.descendInputOfBlock(block, 'STRING2').toType(InputType.STRING)
            });
        case 'operator_divide':
            return new IntermediateInput(InputOpcode.OP_DIVIDE, InputType.NUMBER_OR_NAN, {
                left: this.descendInputOfBlock(block, 'NUM1').toType(InputType.NUMBER),
                right: this.descendInputOfBlock(block, 'NUM2').toType(InputType.NUMBER)
            });
        case 'operator_equals':
            return new IntermediateInput(InputOpcode.OP_EQUALS, InputType.BOOLEAN, {
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            });
        case 'operator_gt':
            return new IntermediateInput(InputOpcode.OP_GREATER, InputType.BOOLEAN, {
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            });
        case 'operator_join':
            return new IntermediateInput(InputOpcode.OP_JOIN, InputType.STRING, {
                left: this.descendInputOfBlock(block, 'STRING1').toType(InputType.STRING),
                right: this.descendInputOfBlock(block, 'STRING2').toType(InputType.STRING)
            });
        case 'operator_length':
            return new IntermediateInput(InputOpcode.OP_LENGTH, InputType.NUMBER, {
                string: this.descendInputOfBlock(block, 'STRING').toType(InputType.STRING)
            });
        case 'operator_letter_of':
            return new IntermediateInput(InputOpcode.OP_LETTER_OF, InputType.STRING, {
                letter: this.descendInputOfBlock(block, 'LETTER').toType(InputType.NUMBER),
                string: this.descendInputOfBlock(block, 'STRING').toType(InputType.STRING)
            });
        case 'operator_lt':
            return new IntermediateInput(InputOpcode.OP_LESS, InputType.BOOLEAN, {
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            });
        case 'operator_mathop': {
            const value = this.descendInputOfBlock(block, 'NUM').toType(InputType.NUMBER);
            const operator = block.fields.OPERATOR.value.toLowerCase();
            switch (operator) {
                case 'abs': return new IntermediateInput(InputOpcode.OP_ABS, InputType.NUMBER, {value});
                case 'floor': return new IntermediateInput(InputOpcode.OP_FLOOR, InputType.NUMBER, {value});
                case 'ceiling': return new IntermediateInput(InputOpcode.OP_CEILING, InputType.NUMBER, {value});
                case 'sqrt': return new IntermediateInput(InputOpcode.OP_SQRT, InputType.NUMBER_OR_NAN, {value});
                case 'sin': return new IntermediateInput(InputOpcode.OP_SIN, InputType.NUMBER, {value});
                case 'cos': return new IntermediateInput(InputOpcode.OP_COS, InputType.NUMBER, {value});
                case 'tan': return new IntermediateInput(InputOpcode.OP_TAN, InputType.NUMBER, {value});
                case 'asin': return new IntermediateInput(InputOpcode.OP_ASIN, InputType.NUMBER_OR_NAN, {value});
                case 'acos':return new IntermediateInput(InputOpcode.OP_ACOS, InputType.NUMBER_OR_NAN, {value});
                case 'atan': return new IntermediateInput(InputOpcode.OP_ATAN, InputType.NUMBER, {value});
                case 'ln': return new IntermediateInput(InputOpcode.OP_LOG_E, InputType.NUMBER_OR_NAN, {value});
                case 'log': return new IntermediateInput(InputOpcode.OP_LOG_10, InputType.NUMBER_OR_NAN, {value});
                case 'e ^': return new IntermediateInput(InputOpcode.OP_POW_E, InputType.NUMBER, {value});
                case '10 ^': return new IntermediateInput(InputOpcode.OP_POW_10, InputType.NUMBER, {value});
                default: this.createConstantInput(0);
            }
        }
        case 'operator_mod':
            return new IntermediateInput(InputOpcode.OP_MOD, InputType.NUMBER_OR_NAN, {
                left: this.descendInputOfBlock(block, 'NUM1').toType(InputType.NUMBER),
                right: this.descendInputOfBlock(block, 'NUM2').toType(InputType.NUMBER)
            });
        case 'operator_multiply':
            return new IntermediateInput(InputOpcode.OP_MULTIPLY, InputType.NUMBER_OR_NAN, {
                left: this.descendInputOfBlock(block, 'NUM1').toType(InputType.NUMBER),
                right: this.descendInputOfBlock(block, 'NUM2').toType(InputType.NUMBER)
            });
        case 'operator_not':
            return new IntermediateInput(InputOpcode.OP_NOT, InputType.BOOLEAN, {
                operand: this.descendInputOfBlock(block, 'OPERAND').toType(InputType.BOOLEAN)
            });
        case 'operator_or':
            return new IntermediateInput(InputOpcode.OP_OR, InputType.BOOLEAN, {
                left: this.descendInputOfBlock(block, 'OPERAND1').toType(InputType.BOOLEAN),
                right: this.descendInputOfBlock(block, 'OPERAND2').toType(InputType.BOOLEAN)
            });
        case 'operator_random': {
            const from = this.descendInputOfBlock(block, 'FROM');
            const to = this.descendInputOfBlock(block, 'TO');
            // If both values are known at compile time, we can do some optimizations.
            // TODO: move optimizations to jsgen?
            if (from.opcode === InputOpcode.CONSTANT && to.opcode === InputOpcode.CONSTANT) {
                const sFrom = from.inputs.value;
                const sTo = to.inputs.value;
                const nFrom = Cast.toNumber(sFrom);
                const nTo = Cast.toNumber(sTo);
                // If both numbers are the same, random is unnecessary.
                // todo: this probably never happens so consider removing
                if (nFrom === nTo) {
                    return this.createConstantInput(nFrom);
                }
                // If both are ints, hint this to the compiler
                if (Cast.isInt(sFrom) && Cast.isInt(sTo)) {
                    return new IntermediateInput(InputOpcode.OP_RANDOM, InputType.NUMBER, {
                        low: (nFrom <= nTo ? from : to).toType(InputType.NUMBER),
                        high: (nFrom <= nTo ? to : from).toType(InputType.NUMBER),
                        useInts: true,
                        useFloats: false
                    });
                }
                // Otherwise hint that these are floats
                return new IntermediateInput(InputOpcode.OP_RANDOM, InputType.NUMBER, {
                    low: (nFrom <= nTo ? from : to).toType(InputType.NUMBER),
                    high: (nFrom <= nTo ? to : from).toType(InputType.NUMBER),
                    useInts: false,
                    useFloats: true
                });
            } else if (from.opcode === InputOpcode.CONSTANT) {
                // If only one value is known at compile-time, we can still attempt some optimizations.
                if (!Cast.isInt(Cast.toNumber(from.inputs.value))) {
                    return new IntermediateInput(InputOpcode.OP_RANDOM, InputType.NUMBER, {
                        low: from.toType(InputType.NUMBER),
                        high: to.toType(InputType.NUMBER),
                        useInts: false,
                        useFloats: true
                    });
                }
            } else if (to.opcode === InputOpcode.CONSTANT) {
                if (!Cast.isInt(Cast.toNumber(from.inputs.value))) {
                    return new IntermediateInput(InputOpcode.OP_RANDOM, InputType.NUMBER, {
                        low: from.toType(InputType.NUMBER),
                        high: to.toType(InputType.NUMBER),
                        useInts: false,
                        useFloats: true
                    });
                }
            }
            // No optimizations possible
            return new IntermediateInput(InputOpcode.OP_RANDOM, InputType.NUMBER, {
                low: from,
                high: to,
                useInts: false,
                useFloats: false
            });
        }
        case 'operator_round':
            return new IntermediateInput(InputOpcode.OP_ROUND, InputType.NUMBER, {
                value: this.descendInputOfBlock(block, 'NUM').toType(InputType.NUMBER)
            });
        case 'operator_subtract':
            return new IntermediateInput(InputOpcode.OP_SUBTRACT, InputType.NUMBER_OR_NAN, {
                left: this.descendInputOfBlock(block, 'NUM1').toType(InputType.NUMBER),
                right: this.descendInputOfBlock(block, 'NUM2').toType(InputType.NUMBER)
            });

        case 'procedures_call':
            return this.descendProcedure(block);

        case 'sensing_answer':
            return new IntermediateInput(InputOpcode.SENSING_ANSWER, InputType.STRING);

        case 'sensing_coloristouchingcolor':
            return new IntermediateInput(InputOpcode.SENSING_COLOR_TOUCHING_COLOR, InputType.BOOLEAN, {
                target: this.descendInputOfBlock(block, 'COLOR2'),
                mask: this.descendInputOfBlock(block, 'COLOR')
            });
        case 'sensing_current':
            switch (block.fields.CURRENTMENU.value.toLowerCase()) {
                case 'year': return new IntermediateInput(InputOpcode.SENSING_TIME_YEAR, InputType.NUMBER);
                case 'month': return new IntermediateInput(InputOpcode.SENSING_TIME_MONTH, InputType.NUMBER);
                case 'date': return new IntermediateInput(InputOpcode.SENSING_TIME_DATE, InputType.NUMBER);
                case 'dayofweek': return new IntermediateInput(InputOpcode.SENSING_TIME_WEEKDAY, InputType.NUMBER);
                case 'hour': return new IntermediateInput(InputOpcode.SENSING_TIME_HOUR, InputType.NUMBER);
                case 'minute': return new IntermediateInput(InputOpcode.SENSING_TIME_MINUTE, InputType.NUMBER);
                case 'second': return new IntermediateInput(InputOpcode.SENSING_TIME_SECOND, InputType.NUMBER);
                default: return this.createConstantInput(0);
            }
        case 'sensing_dayssince2000':
            return new IntermediateInput(InputOpcode.SENSING_TIME_DAYS_SINCE_2000, InputType.NUMBER);
        case 'sensing_distanceto':
            return new IntermediateInput(InputOpcode.SENSING_DISTANCE, InputType.NUMBER, {
                target: this.descendInputOfBlock(block, 'DISTANCETOMENU').toType(InputType.STRING)
            });
        case 'sensing_keypressed':
            return new IntermediateInput(InputOpcode.SENSING_KEY_DOWN, InputType.BOOLEAN, {
                key: this.descendInputOfBlock(block, 'KEY_OPTION', true)
            });
        case 'sensing_mousedown':
            return new IntermediateInput(InputOpcode.SENSING_MOUSE_DOWN, InputType.BOOLEAN);
        case 'sensing_mousex':
            return new IntermediateInput(InputOpcode.SENSING_MOUSE_X, InputType.NUMBER);
        case 'sensing_mousey':
            return new IntermediateInput(InputOpcode.SENSING_MOUSE_Y, InputType.NUMBER);
        case 'sensing_of':
            return new IntermediateInput(InputOpcode.SENSING_OF, InputType.ANY, {
                property: block.fields.PROPERTY.value,
                object: this.descendInputOfBlock(block, 'OBJECT').toType(InputType.STRING)
            });
        case 'sensing_timer':
            this.usesTimer = true;
            return new IntermediateInput(InputOpcode.SENSING_TIMER_GET, InputType.NUMBER);
        case 'sensing_touchingcolor':
            return new IntermediateInput(InputOpcode.SENSING_TOUCHING_COLOR, InputType.BOOLEAN, {
                color: this.descendInputOfBlock(block, 'COLOR')
            });
        case 'sensing_touchingobject':
            return new IntermediateInput(InputOpcode.SENSING_TOUCHING_OBJECT, InputType.BOOLEAN, {
                object: this.descendInputOfBlock(block, 'TOUCHINGOBJECTMENU')
            });
        case 'sensing_username':
            return new IntermediateInput(InputOpcode.SENSING_USERNAME, InputType.STRING);

        case 'sound_sounds_menu':
            // This menu is special compared to other menus -- it actually has an opcode function.
            return this.createConstantInput(block.fields.SOUND_MENU.value);

        case 'tw_getLastKeyPressed':
            return new IntermediateInput(InputOpcode.TW_KEY_LAST_PRESSED, InputType.STRING);

        default: {
            const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);
            if (opcodeFunction) {
                // It might be a non-compiled primitive from a standard category
                if (compatBlocks.inputs.includes(block.opcode)) {
                    return this.descendCompatLayerInput(block);
                }
                // It might be an extension block.
                const blockInfo = this.getBlockInfo(block.opcode);
                if (blockInfo) {
                    const type = blockInfo.info.blockType;
                    if (type === BlockType.REPORTER || type === BlockType.BOOLEAN) {
                        return this.descendCompatLayerInput(block);
                    }
                }
            }

            // It might be a menu.
            const inputs = Object.keys(block.inputs);
            const fields = Object.keys(block.fields);
            if (inputs.length === 0 && fields.length === 1) {
                return this.createConstantInput(block.fields[fields[0]].value);
            }

            log.warn(`IR: Unknown input: ${block.opcode}`, block);
            throw new Error(`IR: Unknown input: ${block.opcode}`);
        }
        }
    }

    /**
     * Descend into a stacked block. (eg. "move ( ) steps")
     * @param {*} block The Scratch block to parse.
     * @private
     * @returns {IntermediateStack} Compiled node for this block.
     */
    descendStackedBlock (block) {
        switch (block.opcode) {
        case 'control_all_at_once':
            // In Scratch 3, this block behaves like "if 1 = 1"
            return new IntermediateStack(StackOpcode.CONTROL_IF_ELSE, {
                condition: this.createConstantInput(true),
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: []
            });
        case 'control_create_clone_of':
            return new IntermediateStack(StackOpcode.CONTROL_CLONE_CREATE, {
                target: this.descendInputOfBlock(block, 'CLONE_OPTION').toType(InputType.STRING)
            });
        case 'control_delete_this_clone':
            this.script.yields = true;
            return new IntermediateStack(StackOpcode.CONTROL_CLONE_DELETE);
        case 'control_forever':
            this.analyzeLoop();
            return new IntermediateStack(StackOpcode.CONTROL_WHILE, {
                condition: this.createConstantInput(true),
                do: this.descendSubstack(block, 'SUBSTACK')
            });
        case 'control_for_each':
            this.analyzeLoop();
            return new IntermediateStack(StackOpcode.CONTROL_FOR, {
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
                count: this.descendInputOfBlock(block, 'VALUE').toType(InputType.NUMBER),
                do: this.descendSubstack(block, 'SUBSTACK')
            });
        case 'control_if':
            return new IntermediateStack(StackOpcode.CONTROL_IF_ELSE, {
                condition: this.descendInputOfBlock(block, 'CONDITION').toType(InputType.BOOLEAN),
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: []
            });
        case 'control_if_else':
            return new IntermediateStack(StackOpcode.CONTROL_IF_ELSE, {
                condition: this.descendInputOfBlock(block, 'CONDITION').toType(InputType.BOOLEAN),
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: this.descendSubstack(block, 'SUBSTACK2')
            });
        case 'control_repeat':
            this.analyzeLoop();
            return new IntermediateStack(StackOpcode.CONTROL_REPEAT, {
                times: this.descendInputOfBlock(block, 'TIMES').toType(InputType.NUMBER),
                do: this.descendSubstack(block, 'SUBSTACK')
            });
        case 'control_repeat_until': {
            this.analyzeLoop();
            // Dirty hack: automatically enable warp timer for this block if it uses timer
            // This fixes project that do things like "repeat until timer > 0.5"
            this.usesTimer = false;
            const condition = this.descendInputOfBlock(block, 'CONDITION');
            const needsWarpTimer = this.usesTimer;
            if (needsWarpTimer) {
                this.script.yields = true;
            }
            return new IntermediateStack(StackOpcode.CONTROL_WHILE, {
                condition: new IntermediateInput(InputOpcode.OP_NOT, InputType.BOOLEAN, {
                    operand: condition
                }),
                do: this.descendSubstack(block, 'SUBSTACK'),
                warpTimer: needsWarpTimer
            });
        }
        case 'control_stop': {
            const level = block.fields.STOP_OPTION.value;
            if (level === 'all') {
                this.script.yields = true;
                return new IntermediateStack(StackOpcode.CONTROL_STOP_ALL);
            } else if (level === 'other scripts in sprite' || level === 'other scripts in stage') {
                return new IntermediateStack(StackOpcode.CONTROL_STOP_OTHERS);
            } else if (level === 'this script') {
                return new IntermediateStack(StackOpcode.CONTROL_STOP_SCRIPT);
            }
            return new IntermediateStack(StackOpcode.NOP);
        }
        case 'control_wait':
            this.script.yields = true;
            return new IntermediateStack(StackOpcode.CONTROL_WAIT, {
                seconds: this.descendInputOfBlock(block, 'DURATION').toType(InputType.NUMBER)
            });
        case 'control_wait_until':
            this.script.yields = true;
            return new IntermediateStack(StackOpcode.CONTROL_WAIT_UNTIL, {
                condition: this.descendInputOfBlock(block, 'CONDITION').toType(InputType.BOOLEAN)
            });
        case 'control_while':
            this.analyzeLoop();
            return new IntermediateStack(StackOpcode.CONTROL_WHILE, {
                condition: this.descendInputOfBlock(block, 'CONDITION').toType(InputType.BOOLEAN),
                do: this.descendSubstack(block, 'SUBSTACK'),
                // We should consider analyzing this like we do for control_repeat_until
                warpTimer: false
            });

        case 'data_addtolist':
            return new IntermediateStack(StackOpcode.LIST_ADD, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM', true)
            });
        case 'data_changevariableby': {
            const variable = this.descendVariable(block, 'VARIABLE', SCALAR_TYPE);
            return new IntermediateStack(StackOpcode.VAR_SET, {
                variable,
                value: new IntermediateInput(InputOpcode.OP_ADD, InputType.NUMBER_OR_NAN, {
                    left: new IntermediateInput(InputOpcode.VAR_GET, InputType.ANY, {variable}).toType(InputType.NUMBER),
                    right: this.descendInputOfBlock(block, 'VALUE').toType(InputType.NUMBER)
                })
            });
        }
        case 'data_deletealloflist':
            return new IntermediateStack(StackOpcode.LIST_DELETE_ALL, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            });
        case 'data_deleteoflist': {
            const index = this.descendInputOfBlock(block, 'INDEX');
            if (index.opcode === InputOpcode.CONSTANT && index.value === 'all') {
                return new IntermediateStack(StackOpcode.LIST_DELETE_ALL, {
                    list: this.descendVariable(block, 'LIST', LIST_TYPE)
                });
            }
            return new IntermediateStack(StackOpcode.LIST_DELETE, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: index
            });
        }
        case 'data_hidelist':
            return new IntermediateStack(StackOpcode.LIST_HIDE, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            });
        case 'data_hidevariable':
            return new IntermediateStack(StackOpcode.VAR_HIDE, {
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            });
        case 'data_insertatlist':
            return new IntermediateStack(StackOpcode.LIST_INSERT, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX'),
                item: this.descendInputOfBlock(block, 'ITEM', true)
            });
        case 'data_replaceitemoflist':
            return new IntermediateStack(StackOpcode.LIST_REPLACE, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX'),
                item: this.descendInputOfBlock(block, 'ITEM', true)
            });
        case 'data_setvariableto':
            return new IntermediateStack(StackOpcode.VAR_SET, {
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
                value: this.descendInputOfBlock(block, 'VALUE', true)
            });
        case 'data_showlist':
            return new IntermediateStack(StackOpcode.LIST_SHOW, {
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            });
        case 'data_showvariable':
            return new IntermediateStack(StackOpcode.VAR_SHOW, {
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            });

        case 'event_broadcast':
            return new IntermediateStack(StackOpcode.EVENT_BROADCAST, {
                broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT').toType(InputType.STRING)
            });
        case 'event_broadcastandwait':
            this.script.yields = true;
            return new IntermediateStack(StackOpcode.EVENT_BROADCAST_AND_WAIT, {
                broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT').toType(InputType.STRING)
            });

        case 'looks_changeeffectby':
            return new IntermediateStack(StackOpcode.LOOKS_EFFECT_CHANGE, {
                effect: block.fields.EFFECT.value.toLowerCase(),
                value: this.descendInputOfBlock(block, 'CHANGE').toType(InputType.NUMBER)
            });
        case 'looks_changesizeby':
            return new IntermediateStack(StackOpcode.LOOKS_SIZE_CHANGE, {
                size: this.descendInputOfBlock(block, 'CHANGE').toType(InputType.NUMBER)
            });
        case 'looks_cleargraphiceffects':
            return new IntermediateStack(StackOpcode.LOOKS_EFFECT_CLEAR);
        case 'looks_goforwardbackwardlayers':
            if (block.fields.FORWARD_BACKWARD.value === 'forward') {
                return new IntermediateStack(StackOpcode.LOOKS_LAYER_FORWARD, {
                    layers: this.descendInputOfBlock(block, 'NUM').toType(InputType.NUMBER)
                });
            }
            return new IntermediateStack(StackOpcode.LOOKS_LAYER_BACKWARD, {
                layers: this.descendInputOfBlock(block, 'NUM').toType(InputType.NUMBER)
            });
        case 'looks_gotofrontback':
            if (block.fields.FRONT_BACK.value === 'front') {
                return new IntermediateStack(StackOpcode.LOOKS_LAYER_FRONT);
            }
            return new IntermediateStack(StackOpcode.LOOKS_LAYER_BACK);
        case 'looks_hide':
            return new IntermediateStack(StackOpcode.LOOKS_HIDE);
        case 'looks_nextbackdrop':
            return new IntermediateStack(StackOpcode.LOOKS_BACKDROP_NEXT);
        case 'looks_nextcostume':
            return new IntermediateStack(StackOpcode.LOOKS_COSTUME_NEXT);
        case 'looks_seteffectto':
            return new IntermediateStack(StackOpcode.LOOKS_EFFECT_SET, {
                effect: block.fields.EFFECT.value.toLowerCase(),
                value: this.descendInputOfBlock(block, 'VALUE').toType(InputType.NUMBER)
            });
        case 'looks_setsizeto':
            return new IntermediateStack(StackOpcode.LOOKS_SIZE_SET, {
                size: this.descendInputOfBlock(block, 'SIZE').toType(InputType.NUMBER)
            });
        case 'looks_show':
            return new IntermediateStack(StackOpcode.LOOKS_SHOW);
        case 'looks_switchbackdropto':
            return new IntermediateStack(StackOpcode.LOOKS_BACKDROP_SET, {
                backdrop: this.descendInputOfBlock(block, 'BACKDROP', true)
            });
        case 'looks_switchcostumeto':
            return new IntermediateStack(StackOpcode.LOOKS_COSTUME_SET, {
                costume: this.descendInputOfBlock(block, 'COSTUME', true)
            });

        case 'motion_changexby':
            return new IntermediateStack(StackOpcode.MOTION_X_CHANGE, {
                dx: this.descendInputOfBlock(block, 'DX').toType(InputType.NUMBER)
            });
        case 'motion_changeyby':
            return new IntermediateStack(StackOpcode.MOTION_Y_CHANGE, {
                dy: this.descendInputOfBlock(block, 'DY').toType(InputType.NUMBER)
            });
        case 'motion_gotoxy':
            return new IntermediateStack(StackOpcode.MOTION_XY_SET, {
                x: this.descendInputOfBlock(block, 'X').toType(InputType.NUMBER),
                y: this.descendInputOfBlock(block, 'Y').toType(InputType.NUMBER)
            });
        case 'motion_ifonedgebounce':
            return new IntermediateStack(StackOpcode.MOTION_IF_ON_EDGE_BOUNCE);
        case 'motion_movesteps':
            return new IntermediateStack(StackOpcode.MOTION_STEP, {
                steps: this.descendInputOfBlock(block, 'STEPS').toType(InputType.NUMBER)
            });
        case 'motion_pointindirection':
            return new IntermediateStack(StackOpcode.MOTION_DIRECTION_SET, {
                direction: this.descendInputOfBlock(block, 'DIRECTION').toType(InputType.NUMBER)
            });
        case 'motion_setrotationstyle':
            return new IntermediateStack(StackOpcode.MOTION_ROTATION_STYLE_SET, {
                style: block.fields.STYLE.value
            });
        case 'motion_setx':
            return new IntermediateStack(StackOpcode.MOTION_X_SET, {
                x: this.descendInputOfBlock(block, 'X').toType(InputType.NUMBER)
            });
        case 'motion_sety':
            return new IntermediateStack(StackOpcode.MOTION_Y_SET, {
                y: this.descendInputOfBlock(block, 'Y').toType(InputType.NUMBER)
            });
        case 'motion_turnleft':
            return new IntermediateStack(StackOpcode.MOTION_DIRECTION_SET, {
                direction: new IntermediateInput(InputOpcode.OP_SUBTRACT, InputType.NUMBER, {
                    left: new IntermediateInput(InputOpcode.MOTION_DIRECTION_GET, InputType.NUMBER),
                    right: this.descendInputOfBlock(block, 'DEGREES')
                })
            });
        case 'motion_turnright':
            return new IntermediateStack(StackOpcode.MOTION_DIRECTION_SET, InputType.NUMBER, {
                direction: new IntermediateInput(InputOpcode.OP_ADD, InputType.NUMBER, {
                    left: new IntermediateInput(InputOpcode.MOTION_DIRECTION_GET, InputType.NUMBER),
                    right: this.descendInputOfBlock(block, 'DEGREES')
                })
            });

        case 'pen_clear':
            return new IntermediateStack(StackOpcode.PEN_CLEAR);
        case 'pen_changePenColorParamBy':
            return new IntermediateStack(StackOpcode.PEN_COLOR_PARAM_CHANGE, {
                param: this.descendInputOfBlock(block, 'COLOR_PARAM').toType(InputType.STRING),
                value: this.descendInputOfBlock(block, 'VALUE').toType(InputType.NUMBER)
            });
        case 'pen_changePenHueBy':
            return new IntermediateStack(StackOpcode.PEN_COLOR_HUE_CHANGE_LEGACY, {
                hue: this.descendInputOfBlock(block, 'HUE').toType(InputType.NUMBER)
            });
        case 'pen_changePenShadeBy':
            return new IntermediateStack(StackOpcode.PEN_COLOR_SHADE_CHANGE_LEGACY, {
                shade: this.descendInputOfBlock(block, 'SHADE').toType(InputType.NUMBER)
            });
        case 'pen_penDown':
            return new IntermediateStack(StackOpcode.PEN_DOWN);
        case 'pen_penUp':
            return new IntermediateStack(StackOpcode.PEN_UP);
        case 'pen_setPenColorParamTo':
            return new IntermediateStack(StackOpcode.PEN_COLOR_PARAM_SET, {
                param: this.descendInputOfBlock(block, 'COLOR_PARAM').toType(InputType.STRING),
                value: this.descendInputOfBlock(block, 'VALUE').toType(InputType.NUMBER)
            });
        case 'pen_setPenColorToColor':
            return new IntermediateStack(StackOpcode.PEN_COLOR_SET, {
                color: this.descendInputOfBlock(block, 'COLOR')
            });
        case 'pen_setPenHueToNumber':
            return new IntermediateStack(StackOpcode.PEN_COLOR_HUE_SET_LEGACY, {
                hue: this.descendInputOfBlock(block, 'HUE').toType(InputType.NUMBER)
            });
        case 'pen_setPenShadeToNumber':
            return new IntermediateStack(StackOpcode.PEN_COLOR_SHADE_SET_LEGACY, {
                shade: this.descendInputOfBlock(block, 'SHADE').toType(InputType.NUMBER)
            });
        case 'pen_setPenSizeTo':
            return new IntermediateStack(StackOpcode.PEN_SIZE_SET, {
                size: this.descendInputOfBlock(block, 'SIZE').toType(InputType.NUMBER)
            });
        case 'pen_changePenSizeBy':
            return new IntermediateStack(StackOpcode.PEN_SIZE_CHANGE, {
                size: this.descendInputOfBlock(block, 'SIZE').toType(InputType.NUMBER)
            });
        case 'pen_stamp':
            return new IntermediateStack(StackOpcode.PEN_STAMP);

        case 'procedures_call': {
            const procedureCode = block.mutation.proccode;
            if (block.mutation.return) {
                const visualReport = this.descendVisualReport(block);
                if (visualReport) {
                    return visualReport;
                }
            }
            if (procedureCode === 'tw:debugger;') {
                return new IntermediateStack(StackOpcode.DEBUGGER);
            }
            const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
            if (paramNamesIdsAndDefaults === null) {
                return new IntermediateStack(StackOpcode.NOP);
            }

            const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;

            const addonBlock = this.runtime.getAddonBlock(procedureCode);
            if (addonBlock) {
                this.script.yields = true;
                const args = {};
                for (let i = 0; i < paramIds.length; i++) {
                    let value;
                    if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                        value = this.descendInputOfBlock(block, paramIds[i], true);
                    } else {
                        value = this.createConstantInput(paramDefaults[i], true);
                    }
                    args[paramNames[i]] = value;
                }
                return new IntermediateStack(StackOpcode.ADDON_CALL, {
                    code: procedureCode,
                    arguments: args,
                    blockId: block.id
                });
            }

            const definitionId = this.blocks.getProcedureDefinition(procedureCode);
            const definitionBlock = this.blocks.getBlock(definitionId);
            if (!definitionBlock) {
                return new IntermediateStack(StackOpcode.NOP);
            }
            const innerDefinition = this.blocks.getBlock(definitionBlock.inputs.custom_block.block);

            let isWarp = this.script.isWarp;
            if (!isWarp) {
                if (innerDefinition && innerDefinition.mutation) {
                    const warp = innerDefinition.mutation.warp;
                    if (typeof warp === 'boolean') {
                        isWarp = warp;
                    } else if (typeof warp === 'string') {
                        isWarp = JSON.parse(warp);
                    }
                }
            }

            const variant = generateProcedureVariant(procedureCode, isWarp);

            if (!this.script.dependedProcedures.includes(variant)) {
                this.script.dependedProcedures.push(variant);
            }

            // Non-warp direct recursion yields.
            if (!this.script.isWarp) {
                if (procedureCode === this.script.procedureCode) {
                    this.script.yields = true;
                }
            }

            const args = [];
            for (let i = 0; i < paramIds.length; i++) {
                let value;
                if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                    value = this.descendInputOfBlock(block, paramIds[i], true);
                } else {
                    value = this.createConstantInput(paramDefaults[i], true);
                }
                args.push(value);
            }

            return new IntermediateStack(StackOpcode.PROCEDURE_CALL, {
                code: procedureCode,
                variant,
                arguments: args
            });
        }
        case 'procedures_return':
            return {
                kind: 'procedures.return',
                value: this.descendInputOfBlock(block, 'VALUE')
            };

        case 'sensing_resettimer':
            return new IntermediateStack(StackOpcode.SENSING_TIMER_RESET);

        default: {
            const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);
            if (opcodeFunction) {
                // It might be a non-compiled primitive from a standard category
                if (compatBlocks.stacked.includes(block.opcode)) {
                    return this.descendCompatLayerStack(block);
                }
                // It might be an extension block.
                const blockInfo = this.getBlockInfo(block.opcode);
                if (blockInfo) {
                    const type = blockInfo.info.blockType;
                    if (type === BlockType.COMMAND) {
                        return this.descendCompatLayerStack(block);
                    }
                }
            }

            // When this thread was triggered by a stack click, attempt to compile as an input.
            // TODO: perhaps this should be moved to generate()?
            if (this.thread.stackClick) {
                try {
                    const inputNode = this.descendInput(block);
                    return new IntermediateStack(StackOpcode.VISUAL_REPORT, {
                        input: inputNode
                    });
                } catch (e) {
                    // Ignore
                }
            }

            log.warn(`IR: Unknown stacked block: ${block.opcode}`, block);
            throw new Error(`IR: Unknown stacked block: ${block.opcode}`);
        }
        }
    }

    /**
     * Descend into a stack of blocks (eg. the blocks contained within an "if" block)
     * @param {*} parentBlock The parent Scratch block that contains the stack to parse.
     * @param {string} substackName The name of the stack to descend into.
     * @private
     * @returns {IntermediateStack} Stacked blocks.
     */
    descendSubstack (parentBlock, substackName) {
        const input = parentBlock.inputs[substackName];
        if (!input) {
            return [];
        }
        const stackId = input.block;
        return this.walkStack(stackId);
    }

    /**
     * Descend into and walk the siblings of a stack.
     * @param {string} startingBlockId The ID of the first block of a stack.
     * @private
     * @returns {Node[]} List of stacked block nodes.
     */
    walkStack (startingBlockId) {
        const result = [];
        let blockId = startingBlockId;

        while (blockId !== null) {
            const block = this.getBlockById(blockId);
            if (!block) {
                break;
            }

            const node = this.descendStackedBlock(block);
            result.push(node);

            blockId = block.next;
        }

        return result;
    }

    /**
     * Descend into a variable.
     * @param {*} block The block that has the variable.
     * @param {string} fieldName The name of the field that the variable is stored in.
     * @param {''|'list'} type Variable type, '' for scalar and 'list' for list.
     * @private
     * @returns {*} A parsed variable object.
     */
    descendVariable (block, fieldName, type) {
        const variable = block.fields[fieldName];
        const id = variable.id;

        if (Object.prototype.hasOwnProperty.call(this.variableCache, id)) {
            return this.variableCache[id];
        }

        const data = this._descendVariable(id, variable.value, type);
        this.variableCache[id] = data;
        return data;
    }

    /**
     * @param {string} id The ID of the variable.
     * @param {string} name The name of the variable.
     * @param {''|'list'} type The variable type.
     * @private
     * @returns {*} A parsed variable object.
     */
    _descendVariable (id, name, type) {
        const target = this.target;
        const stage = this.stage;

        // Look for by ID in target...
        if (Object.prototype.hasOwnProperty.call(target.variables, id)) {
            return createVariableData('target', target.variables[id]);
        }

        // Look for by ID in stage...
        if (!target.isStage) {
            if (stage && Object.prototype.hasOwnProperty.call(stage.variables, id)) {
                return createVariableData('stage', stage.variables[id]);
            }
        }

        // Look for by name and type in target...
        for (const varId in target.variables) {
            if (Object.prototype.hasOwnProperty.call(target.variables, varId)) {
                const currVar = target.variables[varId];
                if (currVar.name === name && currVar.type === type) {
                    return createVariableData('target', currVar);
                }
            }
        }

        // Look for by name and type in stage...
        if (!target.isStage && stage) {
            for (const varId in stage.variables) {
                if (Object.prototype.hasOwnProperty.call(stage.variables, varId)) {
                    const currVar = stage.variables[varId];
                    if (currVar.name === name && currVar.type === type) {
                        return createVariableData('stage', currVar);
                    }
                }
            }
        }

        // Create it locally...
        const newVariable = new Variable(id, name, type, false);
        target.variables[id] = newVariable;

        if (target.sprite) {
            // Create the variable in all instances of this sprite.
            // This is necessary because the script cache is shared between clones.
            // sprite.clones has all instances of this sprite including the original and all clones
            for (const clone of target.sprite.clones) {
                if (!Object.prototype.hasOwnProperty.call(clone.variables, id)) {
                    clone.variables[id] = new Variable(id, name, type, false);
                }
            }
        }

        return createVariableData('target', newVariable);
    }

    descendProcedure (block) {
        const procedureCode = block.mutation.proccode;
        const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
        if (paramNamesIdsAndDefaults === null) {
            return {
                kind: 'noop'
            };
        }

        const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;

        const addonBlock = this.runtime.getAddonBlock(procedureCode);
        if (addonBlock) {
            this.script.yields = true;
            const args = {};
            for (let i = 0; i < paramIds.length; i++) {
                let value;
                if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                    value = this.descendInputOfBlock(block, paramIds[i]);
                } else {
                    value = {
                        kind: 'constant',
                        value: paramDefaults[i]
                    };
                }
                args[paramNames[i]] = value;
            }
            return {
                kind: 'addons.call',
                code: procedureCode,
                arguments: args,
                blockId: block.id
            };
        }

        const definitionId = this.blocks.getProcedureDefinition(procedureCode);
        const definitionBlock = this.blocks.getBlock(definitionId);
        if (!definitionBlock) {
            return {
                kind: 'noop'
            };
        }
        const innerDefinition = this.blocks.getBlock(definitionBlock.inputs.custom_block.block);

        let isWarp = this.script.isWarp;
        if (!isWarp) {
            if (innerDefinition && innerDefinition.mutation) {
                const warp = innerDefinition.mutation.warp;
                if (typeof warp === 'boolean') {
                    isWarp = warp;
                } else if (typeof warp === 'string') {
                    isWarp = JSON.parse(warp);
                }
            }
        }

        const variant = generateProcedureVariant(procedureCode, isWarp);

        if (!this.script.dependedProcedures.includes(variant)) {
            this.script.dependedProcedures.push(variant);
        }

        // Non-warp direct recursion yields.
        if (!this.script.isWarp) {
            if (procedureCode === this.script.procedureCode) {
                this.script.yields = true;
            }
        }

        const args = [];
        for (let i = 0; i < paramIds.length; i++) {
            let value;
            if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                value = this.descendInputOfBlock(block, paramIds[i]);
            } else {
                value = {
                    kind: 'constant',
                    value: paramDefaults[i]
                };
            }
            args.push(value);
        }

        return {
            kind: 'procedures.call',
            code: procedureCode,
            variant,
            arguments: args
        };
    }

    /**
     * Descend into an input block that uses the compatibility layer.
     * @param {*} block The block to use the compatibility layer for.
     * @private
     * @returns {IntermediateInput} The parsed node.
     */
     descendCompatLayerInput (block) {
        this.script.yields = true;

        const inputs = {};
        for (const name of Object.keys(block.inputs)) {
            inputs[name] = this.descendInputOfBlock(block, name, true);
        }
        for (const name of Object.keys(block.fields)) {
            fields[name] = block.fields[name].value;
        }
        return new IntermediateInput(InputOpcode.COMPATIBILITY_LAYER, InputType.ANY, {
            opcode: block.opcode,
            inputs,
            fields
        });
    }

    /**
     * Descend into a stack block that uses the compatibility layer.
     * @param {*} block The block to use the compatibility layer for.
     * @private
     * @returns {IntermediateStack} The parsed node.
     */
    descendCompatLayerStack (block) {
        this.script.yields = true;
        const inputs = {};
        for (const name of Object.keys(block.inputs)) {
            inputs[name] = this.descendInputOfBlock(block, name, true);
        }

        const fields = {};
        for (const name of Object.keys(block.fields)) {
            fields[name] = block.fields[name].value;
        }
        return new IntermediateStack(StackOpcode.COMPATIBILITY_LAYER, {
            opcode: block.opcode,
            blockType,
            inputs,
            fields
        });
    }

    analyzeLoop () {
        if (!this.script.isWarp || this.script.warpTimer) {
            this.script.yields = true;
        }
    }

    readTopBlockComment (commentId) {
        const comment = this.target.comments[commentId];
        if (!comment) {
            // can't find the comment
            // this is safe to ignore
            return;
        }

        const text = comment.text;

        for (const line of text.split('\n')) {
            if (!/^tw\b/.test(line)) {
                continue;
            }

            const flags = line.split(' ');
            for (const flag of flags) {
                switch (flag) {
                case 'nocompile':
                    throw new Error('Script explicitly disables compilation');
                case 'stuck':
                    this.script.warpTimer = true;
                    break;
                }
            }

            // Only the first 'tw' line is parsed.
            break;
        }
    }

    descendVisualReport (block) {
        if (!this.thread.stackClick || block.next) {
            return null;
        }
        try {
            return {
                kind: 'visualReport',
                input: this.descendInput(block)
            };
        } catch (e) {
            return null;
        }
    }

    /**
     * @param {Block} hatBlock
     */
    walkHat (hatBlock) {
        const nextBlock = hatBlock.next;
        const opcode = hatBlock.opcode;
        const hatInfo = this.runtime._hats[opcode];

        if (this.thread.stackClick) {
            // We still need to treat the hat as a normal block (so executableHat should be false) for
            // interpreter parity, but the reuslt is ignored.
            const opcodeFunction = this.runtime.getOpcodeFunction(opcode);
            if (opcodeFunction) {
                return [
                    this.descendCompatLayer(hatBlock),
                    ...this.walkStack(nextBlock)
                ];
            }
            return this.walkStack(nextBlock);
        }

        if (hatInfo.edgeActivated) {
            // Edge-activated HAT
            this.script.yields = true;
            this.script.executableHat = true;
            return [
                {
                    kind: 'hat.edge',
                    id: hatBlock.id,
                    condition: this.descendCompatLayer(hatBlock)
                },
                ...this.walkStack(nextBlock)
            ];
        }

        const opcodeFunction = this.runtime.getOpcodeFunction(opcode);
        if (opcodeFunction) {
            // Predicate-based HAT
            this.script.yields = true;
            this.script.executableHat = true;
            return [
                {
                    kind: 'hat.predicate',
                    condition: this.descendCompatLayer(hatBlock)
                },
                ...this.walkStack(nextBlock)
            ];
        }

        return this.walkStack(nextBlock);
    }

    /**
     * @param {string} topBlockId The ID of the top block of the script.
     * @returns {IntermediateScript}
     */
    generate (topBlockId) {
        this.blocks.populateProcedureCache();

        this.script.topBlockId = topBlockId;

        const topBlock = this.getBlockById(topBlockId);
        if (!topBlock) {
            if (this.script.isProcedure) {
                // Empty procedure
                return this.script;
            }
            throw new Error('Cannot find top block');
        }

        if (topBlock.comment) {
            this.readTopBlockComment(topBlock.comment);
        }

        // We do need to evaluate empty hats
        const hatInfo = this.runtime._hats[topBlock.opcode];
        const isHat = !!hatInfo;
        if (isHat) {
            this.script.stack = this.walkHat(topBlock);
        } else {
            // We don't evaluate the procedures_definition top block as it never does anything
            // We also don't want it to be treated like a hat block
            let entryBlock;
            if (topBlock.opcode === 'procedures_definition') {
                entryBlock = topBlock.next;
            } else {
                entryBlock = topBlockId;
            }

            if (entryBlock) {
                this.script.stack = this.walkStack(entryBlock);
            }
        }

        return this.script;
    }
}

class IRGenerator {
    constructor (thread) {
        this.thread = thread;
        this.blocks = thread.blockContainer;

        this.proceduresToCompile = new Map();
        this.compilingProcedures = new Map();
        /** @type {Object.<string, IntermediateScript>} */
        this.procedures = {};

        this.analyzedProcedures = [];
    }

    addProcedureDependencies (dependencies) {
        for (const procedureVariant of dependencies) {
            if (Object.prototype.hasOwnProperty.call(this.procedures, procedureVariant)) {
                continue;
            }
            if (this.compilingProcedures.has(procedureVariant)) {
                continue;
            }
            if (this.proceduresToCompile.has(procedureVariant)) {
                continue;
            }
            const procedureCode = parseProcedureCode(procedureVariant);
            const definition = this.blocks.getProcedureDefinition(procedureCode);
            this.proceduresToCompile.set(procedureVariant, definition);
        }
    }

    /**
     * @param {ScriptTreeGenerator} generator The generator to run.
     * @param {string} topBlockId The ID of the top block in the stack.
     * @returns {IntermediateScript} Intermediate script.
     */
    generateScriptTree (generator, topBlockId) {
        const result = generator.generate(topBlockId);
        this.addProcedureDependencies(result.dependedProcedures);
        return result;
    }

    /**
     * Recursively analyze a script and its dependencies.
     * @param {IntermediateScript} script Intermediate script.
     */
    analyzeScript (script) {
        let madeChanges = false;
        for (const procedureCode of script.dependedProcedures) {
            const procedureData = this.procedures[procedureCode];

            // Analyze newly found procedures.
            if (!this.analyzedProcedures.includes(procedureCode)) {
                this.analyzedProcedures.push(procedureCode);
                if (this.analyzeScript(procedureData)) {
                    madeChanges = true;
                }
                this.analyzedProcedures.pop();
            }

            // If a procedure used by a script may yield, the script itself may yield.
            if (procedureData.yields && !script.yields) {
                script.yields = true;
                madeChanges = true;
            }
        }
        return madeChanges;
    }

    /**
     * @returns {IntermediateRepresentation} Intermediate representation.
     */
    generate () {
        const entry = this.generateScriptTree(new ScriptTreeGenerator(this.thread), this.thread.topBlock);

        // Compile any required procedures.
        // As procedures can depend on other procedures, this process may take several iterations.
        const procedureTreeCache = this.blocks._cache.compiledProcedures;
        while (this.proceduresToCompile.size > 0) {
            this.compilingProcedures = this.proceduresToCompile;
            this.proceduresToCompile = new Map();

            for (const [procedureVariant, definitionId] of this.compilingProcedures.entries()) {
                if (procedureTreeCache[procedureVariant]) {
                    const result = procedureTreeCache[procedureVariant];
                    this.procedures[procedureVariant] = result;
                    this.addProcedureDependencies(result.dependedProcedures);
                } else {
                    const isWarp = parseIsWarp(procedureVariant);
                    const generator = new ScriptTreeGenerator(this.thread);
                    generator.setProcedureVariant(procedureVariant);
                    if (isWarp) generator.enableWarp();
                    const compiledProcedure = this.generateScriptTree(generator, definitionId);
                    this.procedures[procedureVariant] = compiledProcedure;
                    procedureTreeCache[procedureVariant] = compiledProcedure;
                }
            }
        }

        // Analyze scripts until no changes are made.
        while (this.analyzeScript(entry));

        const ir = new IntermediateRepresentation();
        ir.entry = entry;
        ir.procedures = this.procedures;
        return ir;
    }
}

module.exports = IRGenerator;
